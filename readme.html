**The Project â€“ CS59**

Spencer Reith, Mathew Sebastion
7.15.24
Write-up for Project 00



Summary of the Problem
=================


Create a DSL using ANTLR4 grammar tools to solve an interesting problem. The language should be relatively simple for a domain expert to learn.


Domain
================

Commodities trading.

Defining the Problem & Purpose of the Language
================

Defining the Problem
--------------------------------
There is no programming language with built in tools to analyze commodities prices and predict prices for futures. Languages like Python and R have lots of data analysis tools, but no built-in way to compare a commodity with several factors that could impact its price.\newline

Purpose of the Language
--------------------------------
Our language will mainly be used to answer the following questions:
- What is a fair futures price for a given commodity?
- How do environmental factors impact futures prices for a given commodity?
- Which market futures prices are the furthest off from the user's estimates, and have the highest earning potential.

Example Solutions
================
The following example inputs demonstrate how we would answer the questions above.
NOTE, as discussed in class, it does not make sense for us to go through the process of completing all these calculations
So, we've made a couple of files with arbitrary numbers to get our point across in the meantime. We have left the examples in a pseudocode style to make it easier to understand how it would work and solve the problem, however the actual syntax the users would be using would be much more intuitive and less code like to make it easier to use for non coders

~~~~
## EXAMPLE 1 ##
## A user seeks to adjust a variety of files to account for inflation ##
## These files detail commodity prices ##


COMMODITY corn = {inputs/corn.csv}
COMMODITY wheat = {inputs/wheat.csv}
COMMODITY oil = {inputs/oil.csv}
COMMODITY gold = {inputs/gold.csv}

INFL inflation = {inputs/inflation.csv}

commoditiesList = newArray()
commoditiesList.add(corn, wheat, oil, gold)

for c in commoditiesList:
    newFile = c.normalize(inflation)
    newFile.save(outputs/{c + 'Normalized'})

~~~~

~~~~
OUTPUT FOR EXAMPLE 1:

our code would produce 4 output files.
they will still be in the format of year:price
except, the price will be adjusted for inflation
They would be saved to the following locations:
    outputs/cornNormalized
    outputs/wheatNormalized
    outputs/oilNormalized
    outputs/goldNormalized
~~~~

~~~~
## EXAMPLE 2 ##
## A user seeks to predict the futures price for corn based on rainfall rates, for each of the next 10 years ##
## In this case, the FACTOR file 'rain' details rainfall rates in the region of interest ##
## The for loop iterates through years in a 10 year range


COMMODITY corn = {inputs/corn.csv}

FACTOR rainfall = {inputs/rainfall.csv}


for year in range[1, 10]:
    prediction = corn.futures(previousYears = 30, futureYears = year, factor = rainfall)
    print("Year: ", year)
    print("Prediction: ", prediction)

~~~~

~~~~
OUTPUT FOR EXAMPLE 2:

our code will print out 9 values in the terminal (since the for loop has square brackets, it will be INCLUSIVE of 1 and 10).
it will print "Year: {year}", and the next line will print "Prediction: {prediciton}".

see below

-> Year: 1
-> Prediction: 14.6
-> Year: 2
-> Prediction: 14.6
-> Year: 3
-> Prediction: 14.7
-> Year: 4
-> Prediction: 15.8
-> Year: 5
-> Prediction: 13.6
-> Year: 6
-> Prediction: 14.7
-> Year: 7
-> Prediction: 14.6
-> Year: 8
-> Prediction: 14.3
-> Year: 9
-> Prediction: 14.3
-> Year: 10
-> Prediction: 14.4
~~~~

~~~~
## EXAMPLE 3 ##
## A user seeks to predict the futures price for corn based on rainfall rates, political turmoil, and unemployment rate for next year using a weighted average giving 50% weight to rainfall, 25% weight to political turmoil, 25% weight to unemployment rate for the next 10 years##
## In this case, the FACTOR file 'rain' details rainfall rates in column 2, political turmoil in column 3, and unemployment rates in column 4 in the region of interest ##
## The for loop iterates through years in a 10 year range


COMMODITY corn = {inputs/corn.csv}

FACTOR rainfall = {inputs/rainfall.csv}
FACTOR politicalIndex = {inputs/politicalIndex.csv}
FACTOR unemployment = {inputs/unemployment.csv}

FACTOR aggregate = load(rainfall, politicalIndex, unemployment)

for year in range[1, 10]:
    prediction = corn.futures(previousYears = 30, futureYears = year, factor = (rainfall, .5), (politicalTurmoil, .25), (unemployment,.25))
    print("Year: ", year)
    print("Prediction: ", prediction)

~~~~

~~~~
OUTPUT FOR EXAMPLE 3:

our code will print out 9 values in the terminal (since the for loop has square brackets, it will be INCLUSIVE of 1 and 10).
it will print "Year: {year}", and the next line will print "Prediction: {prediciton}".

see below

-> Year: 1
-> Prediction: 14.6
-> Year: 2
-> Prediction: 14.6
-> Year: 3
-> Prediction: 14.7
-> Year: 4
-> Prediction: 15.8
-> Year: 5
-> Prediction: 13.6
-> Year: 6
-> Prediction: 14.7
-> Year: 7
-> Prediction: 14.6
-> Year: 8
-> Prediction: 14.3
-> Year: 9
-> Prediction: 14.3
-> Year: 10
-> Prediction: 14.4
~~~~

~~~~
## EXAMPLE 4 ##
## A user seeks to check the accuracy of the factors and weights they chose against historical data. Here, the user uses data from 2000-2009 to make a prediction and compares the prediction to the actual data from 2010. The model will calculate the futures price for corn based on rainfall rates, political turmoil, and unemployment rate for next year using a weighted average giving 50% weight to rainfall, 25% weight to political turmoil, 25% weight to unemployment rate, then compare the predicted numbers to the actual numbers##
## In this case, the FACTOR file 'rain' details rainfall rates in column 2, political turmoil in column 3, and unemployment rates in column 4 in the region of interest ##
## The for loop iterates through years in a 10 year range


COMMODITY corn = {inputs/corn.csv}

FACTOR rainfall = {inputs/rainfall.csv}
FACTOR politicalIndex = {inputs/politicalIndex.csv}
FACTOR unemployment = {inputs/unemployment.csv}

FACTOR aggregate = load(rainfall, politicalIndex, unemployment)


prediction = corn.futures(previousYears = 2000-2009, futureYears = year, factor = (rainfall, .5), (politicalTurmoil, .25), (unemployment,.25))
difference = check(prediction, corn.2010)
print("The prediction was off by: ", difference)

~~~~

~~~~
OUTPUT FOR EXAMPLE 3:

our code will print out 1 value in the terminal. see below

-> The prediction was off by +5%
~~~~
Define Functionality
================

We've laid out the logic / pseudo-code for our language's most important functions below:
~~~~
calculating futures ->
    Algorithm will offer different mathematical functions the user can choose to use to calculate the prediction (e.g. linear regression)
    Will offer users the option to choose the years of data to use as input
    Will offer users the option to calculate the prediction using different factors and assign weights for each factor

normalize to account for inflation ->
    create a new CSV file (or CSV-like datastructure)
    for each year in the old file
        calculate that year's price in today's dollars
        insert it into the new CSV file
    return CSV file

saving datastructure to file path ->
    likely, we'll hold the CSV file as a dictionary or similar object potentially a pandas dataframe, keyed by {year:value}
    we'll need to write into a file, at the given file path
    for each key in the dictionary
        col1 = year, col2 = value

Check accuracy of calculation
    Users will able to calculate predictions using their model and then check the accuracy of their calculation model against historical data to determine the efficacy of their selected model.

~~~~






<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>